# 📌 React Basic

## 🤓 react js

### 💡 개념

- 자바스크립트 라이브러리로 사용자 인터페이스를 만드는데 사용
- 오직 view만 신경쓰는 라이브러리

### 💡 리액트 이해

1. 컴포넌트
   - 특정부분이 어떻게 생길지 정하는 선언체
   - 재사용이 가능한 api로 수많은 기능들을 내장하고 있습니다.
   - 컴포넌트 하나에서 해당컴포넌트의 생김새와 작동방식을 정의
2. 랜더링
   - 사용자화면에 뷰를 보여주는 것을 랜더링 이라고 함.
   - 초기랜더링
     - 맨처음 어떻게 보일지 정하는 것
     - render 함수가 있다.
     - 컴포넌트가 어떻게 생겼는지 정의하는 역할
     - Render함수를 실행하면 내부에 있는 컴포넌트들도 재귀적으로 렌더링
     - 최상위 컴포넌트의 렌더링 작업이 끝나면 갖고있는 정보들을 사용하여 HTML마크업을 만들고 실제 페이지의 DOM요소 안에 주입합니다.
   - 조화과정
     - 컴포넌트에 데이터 변화가 있을때 새로운 요소로 갈아끼우는 것을 말합니다.
     - 새로운 데이터를 갖고 render함수가 또 다시 호출됩니다.
     - render 함수가 반환하는 결과를 바로 DOM에 반영하지 않고, 이전 컴포넌트 정보와 현재 컴포넌트 정보를 비교합니다.
     - 둘의 차이를 알아내 최소한의 연산으로 DOM트리를 업데이트 합니다.
       - 결국 최적의 자원을 사용하여 이를 수행하는 것

### 💡 리액트의 특징

- Virtual DOM
  - DOM이란❓
  - Document Object Model
  - 객체로 문서구조를 표현하는 방법
  - 자바스크립트와 CSS를 적용
  - 트리형태라서 특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입할 수 있습니다.
  - XML, HTML
  - 동적UI에 최적화 돼있지 않기 떄문에 자바스크립트를 이용해 동적으로 구현
    - 필요한 이유
      - 웹브라우저 단에 DOM에 변화가 일어나면 웹브라우저가 CSS를 다시연산, 레이아웃 구성, 페이지 리페인트 -> 시간 소모 증가
      - virtualDOM방식을 사용해 DOM업데이트를 추상화함으로써 DOM처리 횟수를 최소화 하고 효율적으로 진행
    - 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용합니다.
      1.  데이터를 업데이트 하면 UI를 Virtual DOM에 리렌더링 합니다.
      2.  이전 Virtual DOM에 있던 내용과 현재 내용을 비교합니다.
      3.  바뀐 부분만 실제 DOM에 적용합니다.

## 🤓 JSX

### 💡 개념

- 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼습니다.
- 브라우저에서 실행되기 전에 번들링되는 과정에서 바벨에 의해 일반 자바스크립트 형태의 코드로 변환됩니다.

### 💡 장점

- 보기쉽고 익숙하다
- 활용도가 높다.

### 💡 문법

1. 감싸인 요소

- 부모요소 하나로 감싸야합니다.

2. 컴포넌트의 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM트리 구조로 이뤄져야한다는 규칙

- <></>

3. 자바스크립트 표현

- {}를 활용해서 자바스크립트 값을 JSX안에서 렌더링 할 수 있습니다.

4. if 문 대신 조건부 연산자
5. JSX안에서 if문을 사용할 수 없습니다.

- { }안에 조건부 연산자를 사용합니다.
- {name === 조건?(true) :(false) }
- AND연산자(&&)를 사용한 조건부 렌더링
- undefined를 렌더링 하지 않기

6. 인라인 스타일링

- css를 카멜표기법으로 작성

7. class 대신 className
8. 꼭 닫아야하는 태그

- 항상 태그를 닫아줘야합니다. 👀 ex) ` <input></input>`

9. 주석

- {/\* 주석은 이렇게 작성 \*/)}

### 💡 ESLint와 Prettier적용하기

- ESLint는 문법검사도구
  - vsCode내에서 바로바로 경고메세지를 확인할 수 있습니다.
- Prettier는 코드 스타일 자동정리 도구입니다.
  - f1 누르고 format 입력하여 사용
  - 커스터마이징이 가능
    - ```javascript
        {
          "singleQuote" : true,
          "semi":true,
          "useTabs":false,
          "tabWidth":2
          }
      ```
    - 작은따옴표 사용, 세미콜론 사용, 탭 사용X, 공백 2칸
  - 설정에서 format on save 체크하면 저장할때마다 바로 적용됩니다.

## 🤓 Component

> 컴포넌트의 기능은 단순한 템플릿 이상입니다. 데이터가 주어졌을 때, UI를 만들어 주는 것, 라이프사이클 API를 이용한 작업처리, 임의 메서드를 만들어 특별한 기능을 줄 수 있습니다.

### 1. 💡 클래스형 컴포넌트

### 2. 💡 함수형 컴포넌트

### props

- props는 properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는 요소.
- props값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정 가능.
- 컴포넌트명.defaultProps = {
  변수명 : '값'
  }
- 디폴트값으로 할당해줍니다.

### children

- 태그사이의 내용을 보여줌
- {props.children}

### 비구조화 할당 문법

- props내부 값 추출
- 구조분해문법이라고도 불리며, 함수의 파라미터 부분에서도 사용할 수 있습니다.

### propTypes를 통한 props검증

- 컴포넌트의 필수 props를 지정하거나 props의 타입을 지정할 때는 propTypes를 사용합니다.
- 컴포넌트의 propTypes를 지정하는 방법
  1. ` import PropTypes from "prop-types";`
  2. ````MyComponent.propTypes = {
         name: PropTypes.string,
         favoriteNumber: PropTypes.number.isRequired,
         };  ```
     ````
- 꼭 사용할 필요는 없지만 협업 시 능률이 좋아진다.
- PropTypes 종류
  1. array : 배열
  2. arrayOf(다른 PropType) : PropType으로 이루어진 배열을 의미.
  3. bool : true, false
  4. func : 함수
  5. number : 숫자
  6. object : 객체
  7. string : 문자열
  8. symbol : ES6의 symbol
  9. node : 렌더링할 수 있는 모든 것
  10. instanceOf : 특정클래스의 인스턴스
  11. oneOf(['dog','cat']) : 주어진 배열요소중 값 하나
  12. oneOfType([React.PropTypes.string, PropTypes.number]) : 주어진 배열 안의 종류 중 하나
  13. objectOf(React.PropTypes.number) : 객체의 모든 키값이 인자로 주어진 PropType인 객체

### 클래스형 컴포넌트에서 props사용하기

- render 함수에서 this.props를 조회하면 됩니다.
- ````class MyComponent extends Component {
      render() {
          const { name, favoriteNumber, children } = this.props; //비구조화 할당
          return (
          <div>
              안녕하세요 제 이름은 {name}입니다. children 값은 {children} 입니다.{" "}
              <br />
              제가 좋아하는 숫자는 {favoriteNumber} 입니다.
          </div>
          );
      }
  } ```
  ````

### state

- 컴포넌트 내부에서 바뀔 수 있는 값을 의미합니다.
- props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값
- 자식 컴포넌트에서 props의 값을 바꿀 수는 없다.
- 클래스 : state <br> 함수 : useState

### 배열 비구조화 할당

- 배열안에 있는 값을 쉽게 추출할 수 있도록 해주는 문법.

## 🤓 EventHandling

### ❗️ 주의사항

1. 이벤트 이름은 카멜 표기법으로 작성
2. 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라 함수형태의 값을 전달.
3. DOM요소에만 이벤트를 설정할 수 있습니다.

### 💡 이벤트 종류

- Clipboard
- Composition
- Keyboard
- Focus
- Form
- Mouse
- Selection
- Touch
- UI
- Wheel
- Media
- Image
- Animation
- Transition

### 이벤트 실습

- e.target.value 하면 event에서 들어오는 값을 구할 수 있다.
- state에 input값 담기 - EventPractice.js에 실습
- 임의메서드 만들기
  - 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달합니다.
- 컴포넌트 자신으로 제대로 가리키기 위해서 메서드를 this와 바인딩하는 작업이 필요
- 이 작업이 불편할 수도 있기 떄문에 **바벨의 transform-class-properties 문법**을 사용하여 화살표 함수 형태로 메서드를 정의.
- 👀 input태그가 여러개일 때는?
  - event객체를 활용 : e.target.name
  - `[e.target.name]: e.target.value`
  - 객체 안에서 key를 [ ]로 감싸면 그안에 넣은 레퍼런스가 가리키는 실제 값이 key값으로 사용됩니다.

### onKeyPress 이벤트핸들링

- 키를 눌렀을때 발생하는 keyPress이벤트 처리

## 🤓 Hook

### 👏 useEffect

- 리액트 컴포넌트가 랜더링될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook입니다.
- 처음 랜더링 될때만 실행하게 해주고 싶으면 빈배열을 넣어주면 됩니다.
- 특정값이 변경될때만 호출하고 싶은 경우 - 배열안에 검사하고 싶은 값을 넣어주면 됩니다.
- 컴포넌트가 언마운트 되기 전이나 업데이트 되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect에서 뒷정리 함수를 반환해줘야 합니다.

### 👏 useReducer

- 다양한 상태를 다른 값으로 업데이트 해주고 싶을 때 사용하는 Hook.
- useReducer에서 액션은 어떤 값도 사용 가능. 값 자체를 액션 값으로 사용.

### 👏 useMemo

- 함수 컴포넌트 내부에서 발생하는 연산을 최적화
- 렌더링 하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시사용하는 방식입니다.

### 👏 useCallback

- 성능최적화를 위해 사용하며, 함수를 재사용할 수 있는 Hook
- 첫번째 파라미터에는 생성하고싶은 함수를 넣고, 두번째 파라미터에는 배열을 넣으면된다.
- 배열은 어떤 값이 바뀌었을 때 함수를 새로 생성해야하는지 명시하는 것 입니다.
- 비어있는 배열을 넣게 되면 렌더링 될 때 만들었던 함수를 계속 재사용.
- 함수내부에서 상태값에 의존해야할 때는 반드시 두번째 파라미터에 배열로 넣어줘야 합니다.

### 👏 useRef

- 함수 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해줍니다.

## 🤓 컴포넌트 반복

> 반복적인 내용을 효율적으로 보여주고 관리하는 방법

### 자바스크립트 배열의 map() 함수

- 자바스크립트 배열 객체의 내장함수인 map 함수 : 반복되는 컴포넌트를 렌더링
- 배열내 각 요소를 원하는 규칙에 따라 변환한 후 그 결과로 새로운 배열을 생성

1. 문법

- `arr.map(callback, [thisArg]`
- callback : 새로운 배열의 요소를 생성하는 함수
  - currentValue : 현재처리하고 있는 요소
  - index : 현재처리하고 있는 요소의 index값
  - array : 현재처리하고 있는 원본 배열
- thisArg (선택항목) : callback 함수 내부에서 사용할 this레퍼런스

2. 예제

```javascript
var numbers = [1, 2, 3, 4, 5];
var processed = numbers.map(function (num) {
  return num * num;
});
console.log(processed);
```

### key

-리액트에서 key는 컴포넌트 배열을 렌더링 했을 때 어떤 원소에 변동이 있었는지 알아내려고 사용.

- key설정
  - map함수의 인자로 전달되는 함수 내부에서 컴포넌트 props를 설정하듯 설정.

### 🙂 기타

- 배열의 push함수 : 기존 배열자체를 변경
- 배열의 concat함수 : 새로운 배열을 만들어준다.
- 📌 불변성 유지 : 리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서 새로운 값을 상태로 설정해야한다.
  - 성능 최적화를 위해
- 배열의 filter 함수 : 특정조건읠 만족하는 원소들만 분류할 수 있습니다.
- 배열의 reduce 함수 : 배열.reduce((누적값, 현재값, 인덱스, 요소)=> {return 결과}, 초기값);

## 🤓 라이프사이클

- 모든 리액트 컴포넌트에는 라이프사이클이 존재합니다.
- 컴포넌트의 수명은 페이지에 렌더링 되기전인 준비과정에서 시작하여 페이지에서 사라질 때 끝납니다.
- 라이프사이클은 **마운트, 업데이트, 언마운트**로 나뉩니다.
  1. 마운트
  - DOM이 생성되고 웹브라우저상에 나타나는 것을 마운트라고 합니다.
  - constructor : 컴포넌트를 새로 만들 때마다 호출되는 클래스생성자 메서드
  - getDerivedStateFromProps : props에 있는 값을 state에 넣을때 사용하는 메서드
  - render : 우리가 준비한 UI를 렌더링하는 메서드
  - componentDidMount : 컴포넌트가 웹브라우저상에 나타난 후 호출하는 메서드.
  2. 업데이트
  - props가 바뀔 때
  - state가 바뀔 때
  - 부모컴포넌트가 리렌더링될 때
  - this.forceUpdate로 강제로 렌더링을 트리거 할 때
  3. 언마운트
  - 마운트의 반대과정
  - 컴포넌트를 DOM에서 제거하는 것을 언마운트라고 합니다.

## 🤓 리액트 라우터로 SPA개발하기

- 웹어플리케이션에서 라우팅이라는 개념은 사용자가 요청한 URL에 따라 알맞은 페이지를 보여주는 것을 의미합니다.
- 라우트 시스템을 구축하기 위한 선택지
  1. 리액트라우터 : 컴포넌트 기반 라우팅시스템 설정
  2. Next.js : 프레임워크. 파일경로기반으로 작동
- 리액트 라우터를 이용하면 손쉽게 싱글페이지어플리케이션을 만들 수 있습니다.

### 싱글페이지 어플리케이션이란?

- 싱글페이지 어플리케이션이란 하나의 페이지로 이루어진 어플리케이션
- html은 한번만 받아와서 웹 어플리케이션을 실행시킨 후, 필요한 데이터만 받아와서 화면에 업데이트하는 것이 싱글페이지 어플리케이션

### 리액트라우터 적용 및 사용법

- 순서
  1. 프로젝트 생성 및 라이브러리 설치
  2. 페이지를 만들고 이동해보기
  3. URL파라미터와 쿼리스트링 사용
  4. 중첩된 라우트 구현
  5. 리액트 라우터의 부가기능 사용

1. npm install react-router-dom --save 입력해 라우터 설치
2. 라우터 적용을 위해 src/index.js 파일에 BrowserRouter 컴포넌트를 사용해 감싸줍니다.
3. 페이지 컴포넌트 만들기
4. Route 컴포넌트로 특정 경로에 원하는 컴포넌트 보여주기

- <Route path="주소규칙" element={보여 줄 컴포넌트 JSX} />
- Route컴포넌트는 Route컴포넌트 내부에서 사용

5. Link컴포넌트를 사용해 링크 보여주기

- <Link to="경로">링크 이름</Link>

### 🤓 URL파라미터와 쿼리스트링

- URL파라미터
  - 주소경로에 유동적인 값을 넣음 ID또는 이름을 사용해 특정데이터를 조회
  - useParams라는 Hook을 사용해 객체형태로 조회할 수 있다.
- 쿼리스트링
  - 주소의 뒷부분에 ?이후 키=값을 &으로 구분하는 형태
  - 키워드 겁색, 페이지네이션, 정렬 방식등 조회에 필요한 옵션을 전달할 때 사용
